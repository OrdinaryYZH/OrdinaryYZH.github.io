## 1. Language

### 1.0 JDK相关

#### 1. javac

javac -help
用法: javac <options> <source files>
其中, 可能的选项包括:
  -g                         生成所有调试信息
  -g:none                    不生成任何调试信息
  -g:{lines,vars,source}     只生成某些调试信息
  -nowarn                    不生成任何警告
  -verbose                   输出有关编译器正在执行的操作的消息
  -deprecation               输出使用已过时的 API 的源位置
  -classpath <路径>            指定查找用户类文件和注释处理程序的位置
  -cp <路径>                   指定查找用户类文件和注释处理程序的位置
  -sourcepath <路径>           指定查找输入源文件的位置
  -bootclasspath <路径>        覆盖引导类文件的位置
  -extdirs <目录>              覆盖所安装扩展的位置
  -endorseddirs <目录>         覆盖签名的标准路径的位置
  -proc:{none,only}          控制是否执行注释处理和/或编译。
  -processor <class1>[,<class2>,<class3>...] 要运行的注释处理程序的名称; 绕过默认的搜索进程
  -processorpath <路径>        指定查找注释处理程序的位置
  -parameters                生成元数据以用于方法参数的反射
  -d <目录>                    指定放置生成的类文件的位置
  -s <目录>                    指定放置生成的源文件的位置
  -h <目录>                    指定放置生成的本机标头文件的位置
  -implicit:{none,class}     指定是否为隐式引用文件生成类文件
  -encoding <编码>             指定源文件使用的字符编码
  -source <发行版>              提供与指定发行版的源兼容性
  -target <发行版>              生成特定 VM 版本的类文件
  -profile <配置文件>            请确保使用的 API 在指定的配置文件中可用
  -version                   版本信息
  -help                      输出标准选项的提要
  -A关键字[=值]                  传递给注释处理程序的选项
  -X                         输出非标准选项的提要
  -J<标记>                     直接将 <标记> 传递给运行时系统
  -Werror                    出现警告时终止编译
  @<文件名>                     从文件读取选项和文件名

### 1.  .java常用定义 

1. 类
   1. 普通类
   2. 抽象类
   3. final类
2. 接口
3. 方法
4. 属性



### final关键字

1. final修饰变量，则等同于常量
2. final修饰方法中的参数，PS：不知道实际用处
3. final修饰类，则类不能被继承
4. final修饰方法，则方法不能被重写。

> 不能跟abstract一起用

### abstract关键字

#### 抽象类

1. 包含抽象方法的类必须定义为抽象类； 
2. 抽象类不一定包含抽象方法，也可以包含普通方法；
3.  **抽象类有构造方法，但是不能new一个对象**；
4.  抽象类只支持单继承。 

### new 对象的执行顺序

> 父静态->子静态
>
> 父变量->父初始化区->父构造
>
>  子变量->子初始化区->子构造

参考：[链接](https://www.nowcoder.com/test/question/done?tid=16140014&qid=14764)

### 构造方法

#### 构造方法不能被子类继承

参考：[调用父类构造器](https://segmentfault.com/a/1190000008795969#articleHeader7)

在一个构造器中调用另一个重载的构造器使用this来完成，在子类构造器使用super调用来完成。this和super调用构造器必须出现在构造器执行体的第一行。

子类构造器调用父类构造器分如下几种情况：

1. 子类构造器执行体的第一行使用super显式调用父类构造器，系统将根据super调用里传入的实参列表调用父类对应的构造器。
2. 子类构造器执行体的第一行代码使用this显式调用本类中重载构造器，系统将根据this调用里传入的实参列表调用本类中的另一个构造器。执行本类中另一个构造器时即会调用父类构造器。
3. 子类构造器执行体中既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。

创建任何java对象，最先执行的总是java.lang.Object类的构造器。即，创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果某个父类通过this调用了同类中重载的构造器，就会依次执行此父类的多个构造器。



#### super()和this()

1）调用super()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。

2）super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。

3）super()和this()均需放在构造方法内第一行。

4）尽管可以用this调用一个构造器，但却不能调用两个。

5）this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。

6）this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。

7）从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。



### 标识符

> 标识符是以字母开头的字母数字序列：
>
> 数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；
>
> 字母、数字等字符的任意组合，不能包含+、- *等字符；
>
> 不能使用关键字；
>
> 大小写敏感



### 运算符

<<表示左移位

\>>表示带符号右移位

\>>>表示无符号右移

但是没有<<<运算符



### 重载

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。

原则如下：

一.方法名一定要相同。
二.方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
1.如果参数个数不同，就不管它的参数类型了！
2.如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
三.方法的返回类型、修饰符可以相同，也可不同。



### Object

#### finalize 



## 集合

### Hash和HashTable注意

HashTable不允许null值(key和value都不可以),null的key会报NullPointerException,null的value也会被确保不为空:

```java
// Make sure the value is not null
if (value == null) {
	throw new NullPointerException();
}
```

HashMap允许null值(key和value都可以)。 



### 迭代器相关

#### 一：快速失败（fail—fast）

​          在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。

​          原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。

​      注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。

​      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

#### 二：安全失败（fail—safe）

​      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。

​      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。

​      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。

​          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。



## 7. 并发

### CopyOnWriteArrayList 

用于**写少读多**的并发场景 



### ReadWriteLock 



## 8. 类加载器

### 8.1 基础

1. Bootstrap ClassLoader
   负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

 

2. Extension ClassLoader
   负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

 

3. App ClassLoader
   负责记载classpath中指定的jar包及目录中class

 

4. Custom ClassLoader
   属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

### 类加载顺序

(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)

(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )

(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )

(4) 父类构造函数

(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )

(6) 子类构造函数



## 8. JavaEE

### 8.1 Servlet

#### 8.1.1 Servlet继承图

![Servlet继承图](https://ws1.sinaimg.cn/large/8747d788gy1fs4ybyhvocj21me1c0dv8.jpg)

#### 8.1.2 Servlet请求过程

> HttpServlet容器响应Web客户请求流程如下：
>
> 1）Web客户向Servlet容器发出Http请求；
>
> 2）Servlet容器解析Web客户的Http请求；
>
> 3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；
>
> 4）Servlet容器创建一个HttpResponse对象；
>
> 5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；
>
> 6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；
>
> 7）HttpServlet调用HttpResponse的有关方法，生成响应数据；
>
> 8）Servlet容器把HttpServlet的响应结果传给Web客户。
> doGet() 或 doPost() 是创建HttpServlet时需要覆盖的方法.



#### 8.1.2 Servlet生命周期 

> 1.初始化阶段  调用init()方法
>
> 2.响应客户请求阶段　　调用service()方法
>
> 3.终止阶段　　调用destroy()方法