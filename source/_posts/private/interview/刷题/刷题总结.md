## 语法

### *.java

```
能有一个与文件名相同的public类，可以包含其他非public类（不考虑内部类）
它的内部类也可以是Public类
```



### 1.0 JDK相关

#### 1. javac

javac -help
用法: javac <options> <source files>
其中, 可能的选项包括:
  -g                         生成所有调试信息
  -g:none                    不生成任何调试信息
  -g:{lines,vars,source}     只生成某些调试信息
  -nowarn                    不生成任何警告
  -verbose                   输出有关编译器正在执行的操作的消息
  -deprecation               输出使用已过时的 API 的源位置
  -classpath <路径>            指定查找用户类文件和注释处理程序的位置
  -cp <路径>                   指定查找用户类文件和注释处理程序的位置
  -sourcepath <路径>           指定查找输入源文件的位置
  -bootclasspath <路径>        覆盖引导类文件的位置
  -extdirs <目录>              覆盖所安装扩展的位置
  -endorseddirs <目录>         覆盖签名的标准路径的位置
  -proc:{none,only}          控制是否执行注释处理和/或编译。
  -processor <class1>[,<class2>,<class3>...] 要运行的注释处理程序的名称; 绕过默认的搜索进程
  -processorpath <路径>        指定查找注释处理程序的位置
  -parameters                生成元数据以用于方法参数的反射
  -d <目录>                    指定放置生成的类文件的位置
  -s <目录>                    指定放置生成的源文件的位置
  -h <目录>                    指定放置生成的本机标头文件的位置
  -implicit:{none,class}     指定是否为隐式引用文件生成类文件
  -encoding <编码>             指定源文件使用的字符编码
  -source <发行版>              提供与指定发行版的源兼容性
  -target <发行版>              生成特定 VM 版本的类文件
  -profile <配置文件>            请确保使用的 API 在指定的配置文件中可用
  -version                   版本信息
  -help                      输出标准选项的提要
  -A关键字[=值]                  传递给注释处理程序的选项
  -X                         输出非标准选项的提要
  -J<标记>                     直接将 <标记> 传递给运行时系统
  -Werror                    出现警告时终止编译
  @<文件名>                     从文件读取选项和文件名

### 1.  .java常用定义 

1. 类
   1. 普通类
   2. 抽象类
   3. final类
2. 接口
3. 方法
4. 属性



访问权限修饰符

 

### Java中的修饰符

1. public：共有访问。对所有的类都可见。
2. protected：保护型访问。对同一个包可见，对不同的包的子类可见。
3. default：默认访问权限。只对同一个包可见，注意对不同的包的子类不可见。
4. private：私有访问。只对同一个类可见，其余都不见。

 

非访问权限修饰符

1. static 修饰符，用来创建类方法和类变量。
2. final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。
3. abstract 修饰符，用来创建抽象类和抽象方法。
4. synchronized 用于多线程的同步。
5. volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
6. transient：序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。



### final关键字

#### 知识点1

1. final修饰变量，则等同于常量
2. final修饰方法中的参数，PS：不知道实际用处
3. final修饰类，则类不能被继承
4. final修饰方法，则方法不能被重写。

> 不能跟abstract一起用

#### 知识点2

final作为对象成员存在时，必须初始化；但是，如果不初始化，也可以在类的构造函数中初始化

因为java允许将数据成员声明为final，却不赋初值。但是，blank finals（指声明时没有赋值，例如final int a;此时a可在构造代码块或构造函数中进行初始化 ）必须在使用之前初始化，且必须在构造函数中初始化  



### abstract关键字

#### 抽象类

1. 包含抽象方法的类必须定义为抽象类； 
2. 抽象类不一定包含抽象方法，也可以包含普通方法；
3. **抽象类有构造方法，但是不能new一个对象**；
4. 抽象类只支持单继承。 
5. 以前抽象方法默认是protected，jdk1.8以后改成默认default了 https://www.nowcoder.com/questionTerminal/29c74dd837124f2e895de47fb7c345b6

abstract关键字不可以与final，private,static关键字共存 https://www.nowcoder.com/test/question/done?tid=16747025&qid=36678#summary





### new 对象的执行顺序

> 父静态 -> 子静态
>
> 父成员变量/构造块 -> 父构造方法
>
> 子成员变量/构造块 -> 子构造方法

参考：[链接](https://www.nowcoder.com/test/question/done?tid=16140014&qid=14764)



### 接口

实现接口/重写方法时

1. 方法名相同，参数类型相同
2. 子类返回类型小于等于父类方法返回类型，  
3. 子类抛出异常小于等于父类方法抛出异常， 
4.  子类访问权限大于等于父类方法访问权限。

![](http://ww1.sinaimg.cn/large/8747d788gy1ft84p18e8oj22700rwad8.jpg)

### 构造方法

#### 构造方法不能被子类继承

参考：[调用父类构造器](https://segmentfault.com/a/1190000008795969#articleHeader7)

在一个构造器中调用另一个重载的构造器使用this来完成，在子类构造器使用super调用来完成。this和super调用构造器必须出现在构造器执行体的第一行。

子类构造器调用父类构造器分如下几种情况：

1. 子类构造器执行体的第一行使用super显式调用父类构造器，系统将根据super调用里传入的实参列表调用父类对应的构造器。
2. 子类构造器执行体的第一行代码使用this显式调用本类中重载构造器，系统将根据this调用里传入的实参列表调用本类中的另一个构造器。执行本类中另一个构造器时即会调用父类构造器。
3. 子类构造器执行体中既没有super调用，也没有this调用，系统将会在执行子类构造器之前，隐式调用父类无参数的构造器。

创建任何java对象，最先执行的总是java.lang.Object类的构造器。即，创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果某个父类通过this调用了同类中重载的构造器，就会依次执行此父类的多个构造器。



#### super()和this()

作用：super()和this()类似,区别是，super从子类中调用父类的构造方法，this()在同一类内调用其它方法。

规则：

1. 调用super()和this()必须写在子类构造方法的第一行，否则编译不通过。每个子类构造方法的第一条语句，都是隐含地调用super()，如果父类没有这种形式的构造函数，那么在编译的时候就会报错。
2. 尽管可以用this调用一个构造器，但却不能调用两个。//super也不能
3. this和super不能同时出现在一个构造函数里面（因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。）
4. this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。



### 标识符

> 标识符是以字母开头的字母数字序列：
>
> 数字是指0~9，字母指大小写英文字母、下划线（_)和美元符号（$），也可以是Unicode字符集中的字符，如汉字；
>
> 字母、数字等字符的任意组合，不能包含+、- *等字符；
>
> 不能使用关键字；
>
> 大小写敏感



### 运算符

<<表示左移位

\>>表示带符号右移位

\>>>表示无符号右移

但是没有<<<运算符



### 重载

**重载就是一句话：同名不同参，返回值无关。**

**覆盖/重写：同名同参**

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数的类型或参数的个数。

原则如下：

一.方法名一定要相同。
二.方法的参数表必须不同，包括参数的类型或个数，以此区分不同的方法体。
1.如果参数个数不同，就不管它的参数类型了！
2.如果参数个数相同，那么参数的类型或者参数的顺序必须不同。
三.方法的返回类型、修饰符可以相同，也可不同。



### Object

#### finalize 



### try catch finally

#### 执行顺序

**finally块的语句在try或catch中的return语句执行之后返回之前执行且finally里的修改语句可能影响也可能不影响try或catch中 return已经确定的返回值（按值传递），若finally里也有return语句则覆盖try或catch中的return语句直接返回。** 

参考：[Java finally语句到底是在return之前还是之后执行？](https://www.cnblogs.com/lanxuezaipiao/p/3440471.html)

### 值相关

#### 基本数据类型比较

两个数值进行二元操作时，会有如下的转换操作：

如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。

否则，如果其中一个操作数是float类型，另一个将会转换为float类型。

否则，如果其中一个操作数是long类型，另一个会转换为long类型。

否则，两个操作数都转换为int类型。

---

**1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；**

         int a = 220;
    
         Integer b = 220;
    
        System.out.println(a == b); //true
**2、两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。**

        Integer c=3;
    
        Integer h=3;
    
        Integer e=321;
    
        Integer f=321;
    
        System.out.println(c==h);//true
    
        System.out.println(e==f);//false

**3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。**

        Integer a=1;
    
        Integer b=2;
    
        Integer c=3;
    
        System.out.println(c.equals(a+b));//true

**4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。**  

        int i=1;
    
        int j = 2;
    
        Integer c=3;
    
        System.out.println(c.equals(i+j));//true





####  例子

long test=012			 // √
float f=-412				 // √
int other =(int)true		 // ×
double d=0x12345678	 // √
byte b=128				 // × ，byte b = 127就可以；short s = 32767可以，但是=32768就不可以



## 数组

### 二维数组

```java
char[][] ch = new char[2][3]
```

```java
char[][] ch= new char[2][];
```

## 集合

### Hash和HashTable注意

HashTable不允许null值(key和value都不可以),null的key会报NullPointerException,null的value也会被确保不为空:

```java
// Make sure the value is not null
if (value == null) {
	throw new NullPointerException();
}
```

HashMap允许null值(key和value都可以)。 



### 迭代器相关

#### 一：快速失败（fail—fast）

          在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的结构进行了修改（增加、删除），则会抛出Concurrent Modification Exception。
    
          原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果结构发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。
    
      注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。
    
      场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。

#### 二：安全失败（fail—safe）

      采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。
    
      原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。
    
      缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。
    
          场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。



## 字符串

### 子串

串中任意个连续的字符组成的子序列称为该串的子串 

ab的子串：a、b、ab和一个空子串共4个即（2+1+1）个，abc的子串：a、 b、 c、 ab、 bc 、abc和一个空子串 共（3+2+1+1）个，

所以若字符串的长度为n,则子串的个数就是[n*(n+1)/2]+1个，"software"中**非空子串**的个数就是8+7+....+1=36个。

非空子串：n（n+1）/2

非空真子串：n（n+1）/2 - 1



### 代码点与代码单元

**代码点（Code Point）**：在 Unicode 代码空间中的一个值，取值 0x0 至 0x10FFFF，代表一个字符。
**代码单元（Code Unit）**：在具体编码形式中的最小单位。比如 UTF-16 中一个 code unit 为 16 bits，UTF-8 中一个 code unit 为 8 bits。



### '+'

+号是Java 的操作符重载，会调用StringBuilder.append()



### 编码转换

`String (byte[] bytes, String charsetName)` 通过使用指定的 charset 解码指定的 byte 数组，构造一个新的 String   byte[] -> String
`String.getBytes(Charset charset)`  使用给定的 charset 将此 String 编码到 byte 序列，并将结果存储到新的 byte 数组    String -> byte[]



## 内部类

（ 1 ）对于外部类而言，它也可以使用访问控制符修饰，但外部类只能有两种访问控制级别： public 和默认。因为外部类没有处于任何类的内部，也就没有其所在类的内部、所在类的子类两个范围，因此 private 和 protected 访问控制符对外部类没有意义。

【从组织结构来分析：

类的成员（包过变量、方法、内部类等）的上层结构是类，而类的上层结构是包。

如果类可以使用private来修饰，**表示该包下的这个类不能被其它类访问，那么该类也失去了存在的意义**，所以不能使用private来修饰类。

如果类可以使用protected来修饰，**表示该类所在的包的其它类可以访问该类；该类所在的包的子包的类可以访问该类，但是包没有继承的概念，所以后一句是不对**。所以用protected来修饰类也是没有意义的。

综上，类只有public和default修饰。】

（ 2 ）内部类（静态内部类和成员内部类）的上一级程序单元是外部类，它具有 4 个作用域

（ 3 ）因为局部成员的作用域是所在方法，其他程序单元永远不可能访问另一个方法中的局部变量，所以所有的局部成员都不能使用访问控制修饰符修饰(可以把局部内部类当做一个局部变量，所以它是不需要加任何修饰符的 )

外部类可以继承静态内部类；

但是外部类继承成员内部类时，首先在继承语句extends处，注意命名空间，需要加上外围类名，才能对应上正确的内部类。其次是构造对象上，这里需要自己写一个接受外围类引用的构造器，来给导出类提供创建对象的基本环境。注意在构造器中的这一句**wi.super()**这是必须在构造器中使用的，才能够成功的构造出一个继承自内部类的对象。及**enclosingClassReference.super()**这个语法一定要牢记。  参考:https://blog.csdn.net/yuwenhao07/article/details/53638954



## 网络

### Socket基本使用

Socket套接字 

就是源Ip地址，目标IP地址，源端口号和目标端口号的组合

服务器端：ServerSocket提供的实例

ServerSocket server= new ServerSocket(端口号)

客户端：Socket提供的实例

Socket soc=new Socket(ip地址，端口号)



## 7. 并发

### CopyOnWriteArrayList 

用于**写少读多**的并发场景 



### ReadWriteLock 



### 终止线程

哪些会导致InterruptedException ：

1. Thread.join
2. Thread.sleep
3. Object.wait
4. CyclicBarrier.await




## 8. 类加载器

### 8.1 基础

1. Bootstrap ClassLoader
   负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类

 

2. Extension ClassLoader
   负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包

 

3. App ClassLoader
   负责记载classpath中指定的jar包及目录中class

 

4. Custom ClassLoader
   属于应用程序根据自身需要自定义的ClassLoader，如tomcat、jboss都会根据j2ee规范自行实现ClassLoader

加载过程中会先检查类是否被已加载，检查顺序是自底向上，从Custom ClassLoader到BootStrap ClassLoader逐层检查，只要某个classloader已加载就视为已加载此类，保证此类只所有ClassLoader加载一次。而加载的顺序是自顶向下，也就是由上层来逐层尝试加载此类。

### 类加载顺序

(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)

(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )

(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )

(4) 父类构造函数

(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )

(6) 子类构造函数



## JavaEE

### 1 Servlet

#### 1.1 Servlet继承图

![Servlet继承图](https://ws1.sinaimg.cn/large/8747d788gy1fs4ybyhvocj21me1c0dv8.jpg)

#### 1.2 Servlet请求过程

> HttpServlet容器响应Web客户请求流程如下：
>
> 1）Web客户向Servlet容器发出Http请求；
>
> 2）Servlet容器解析Web客户的Http请求；
>
> 3）Servlet容器创建一个HttpRequest对象，在这个对象中封装Http请求信息；
>
> 4）Servlet容器创建一个HttpResponse对象；
>
> 5）Servlet容器调用HttpServlet的service方法，这个方法中会根据request的Method来判断具体是执行doGet还是doPost，把HttpRequest和HttpResponse对象作为service方法的参数传给HttpServlet对象；
>
> 6）HttpServlet调用HttpRequest的有关方法，获取HTTP请求信息；
>
> 7）HttpServlet调用HttpResponse的有关方法，生成响应数据；
>
> 8）Servlet容器把HttpServlet的响应结果传给Web客户。
> doGet() 或 doPost() 是创建HttpServlet时需要覆盖的方法.



#### 1.2 Servlet生命周期 

> 1.初始化阶段  调用init()方法
>
> 2.响应客户请求阶段　　调用service()方法
>
> 3.终止阶段　　调用destroy()方法



#### Cookie

知识点，客户端禁用Cookie时

**1.** **Java Servlet API 中引用 Session 机制来追踪客户的状态。Servlet API 中定义了 javax.servlet.http.HttpSession 接口，Servlet 容器必须实现这个接口。**

**2.当一个 Session 开始时，Servlet 容器将创建一个 HttpSession 对象，Servlet 容器为 HttpSession 分配一个唯一标识符，称为 Session ID。Servlet 容器将 Session ID 作为 Cookie 保存在客户的浏览器中。每次客户发出 HTTP 请求时，Servlet 容器可以从 HttpRequest 对象中读取 Session ID，然后根据 Session ID 找到相应的 HttpSession 对象，从而获取客户的状态信息。**

**3.当客户端浏览器中禁止 Cookie，Servlet 容器无法从客户端浏览器中取得作为 Cookie 的 Session ID，也就无法跟踪客户状态。**  

**Java Servlet API 中提出了跟踪 Session 的另一种机制，如果客户端浏览器不支持 Cookie，Servlet 容器可以重写客户请求的 URL，把 Session ID 添加到 URL 信息中。**  

**4.** **HttpServletResponse 接口提供了重写 URL 的方法：public java.lang.String encodeURL(java.lang.String url)**  

**该方法的实现机制为：**   

 

**● 先判断当前的 Web 组件是否启用 Session，如果没有启用 Session，直接返回参数 url。**   
**● 再判断客户端浏览器是否支持 Cookie，如果支持 Cookie，直接返回参数 url；如果不支持 Cookie，就在参数 url 中加入 Session ID 信息，然后返回修改后的 url。**   

**我们可以对网页中的链接稍作修改，解决以上问题：**

**修改前：**

**<a href=“maillogin.jsp“>**   
**修改后：**  

**<a href=“<%=response.encodeURL(“maillogin.jsp“)%>“>**    



#### ServletContext

常用方法：

1. getParameter()是获取POST/GET传递的参数值；
2. getInitParameter获取Tomcat的server.xml中设置Context的初始化参数
3. getAttribute()是获取对象容器中的数据值；
4. getRequestDispatcher是请求转发。 



### 8.2 JSP

#### 九个内置对象

| NO.  | 内置对象        | 类型                                       |
| ---- | --------------- | ------------------------------------------ |
| 1    | **pageContext** | **javax.servlet.jsp.PageContext**          |
| 2    | **request**     | **javax.servlet.http.HttpServletRequest**  |
| 3    | **response**    | **javax.servlet.http.HttpServletResponse** |
| 4    | **session**     | **javax.servlet.http.HttpSession**         |
| 5    | **application** | **javax.servlet.ServletContext**           |
| 6    | **config**      | **javax.servlet.ServletConfig**            |
| 7    | out             | javax.servlet.jsp.JspWriter                |
| 8    | page            | java.lang.Object                           |
| 9    | exception       | java.lang.Throwable                        |



#### exception

在 myjsp.jsp 中，关于下面的代码说法错误的是： (  )   

<%@ page language="java" import="java.util.*" errorPage="error.jsp" isErrorPage="false" %> 

https://www.nowcoder.com/test/question/done?tid=16690846&qid=15246#summary

exception是JSP九大内置对象之一，其实例代表其他页面的异常和错误。只有当页面是错误处理页面时，即isErroePage为 true时，该对象才可以使用。对于C项，errorPage的实质就是JSP的异常处理机制,发生异常时才会跳转到 errorPage指定的页面，没必要给errorPage再设置一个errorPage。所以当errorPage属性存在时， isErrorPage属性值为false 



## Java综合

### 构造函数何时被调用

构造方法new，序列化对象，反射，克隆分别创建一个对象的方法，，只有new和反射用到了构造方法 



## 数据库

### 索引











