# (21) 内部类的本质 

## 1. **内部类**

> 概念：一个类里面放另一个类，这个类就称作**内部类**
>
> 作用：为什么要放到别的类内部呢？**一般而言，内部类与包含它的外部类有比较密切的关系，而与其他类关系不大，定义在类内部，可以实现对外部完全隐藏，可以有更好的封装性，代码实现上也往往更为简洁**。
>
> 注意：不过，内部类只是**Java编译器**的概念，对于**Java虚拟机**而言，**每个内部类最后都会被编译为一个独立的类，生成一个独立的字节码文件**。
>
> 其他好处：
>
> 1、内部类可以方便的访问外部类的私有变量
>
> 2、可以声明为private从而实现对外完全隐藏
>
> 3、相关代码写在一起，写法也更为简洁

在Java中，根据定义的位置和方式不同，主要有四种内部类：

1. 静态内部类
2. 成员内部类
3. 方法内部类
4. 匿名内部类

成员内部类和静态内部类可以被外部使用，不过它们都可以被声明为private，这样，外部就使用不了了。

方法内部类是在一个方法内定义和使用的，匿名内部类使用范围更小，它们都不能在外部使用

## 2. **静态内部类**

### 2.1 语法

静态内部类与静态变量和静态方法定义的位置一样，也带有static关键字，只是它定义的是类，示例代码如下：

```java
public class Outer {
    private static int shared = 100;
    
    public static class StaticInner {
        public void innerMethod(){
            System.out.println("inner " + shared);
        }
    }
    
    public void test(){
        StaticInner si = new StaticInner();
        si.innerMethod();
    }
}
```

语法上，静态内部类除了位置放在别的类内部外，它与一个独立的类差别不大，可以有

1. 静态变量
2. 静态方法
3. 成员方法
4. 成员变量
5. 构造方法等

**静态内部类与外部类的联系也不大**（与后面其他内部类相比）。它可以访问外部类的**静态变量和方法**，如innerMethod直接访问shared变量，**但不可以访问实例变量和方法**。在类内部，可以直接使用内部静态类，如test()方法所示。

public静态内部类可以被外部使用，只是需要通过"外部类.静态内部类"的方式使用，如下所示：

```java
Outer.StaticInner si = new Outer.StaticInner();
si.innerMethod();
```

### 2.2 **实现原理**

以上代码实际上会生成两个类，一个是Outer，另一个是`Outer$StaticInner`，它们的代码大概如下所示：

```java
public class Outer {
    private static int shared = 100;
    
    public void test(){
        Outer$StaticInner si = new Outer$StaticInner();
        si.innerMethod();
    }
    
    static int access$0(){
        return shared;
    }
}
```

```java
public class Outer$StaticInner {
    public void innerMethod() {
        System.out.println("inner " + Outer.access$0());
    }
}
```

内部类访问了外部类的一个私有静态变量shared，而我们知道私有变量是不能被类外部访问的，Java的解决方法是，自动为Outer生成了一个非私有访问方法access$0，它返回这个私有静态变量shared。

**注意：`StaticInner`的static关键字没了**

### 2.3 **使用场景**

静态内部类使用场景是很多的，如果**它与外部类关系密切，且不依赖于外部类实例**，则可以考虑定义为静态内部类。

比如说，一个类内部，如果既要计算最大值，也要计算最小值，可以在一次遍历中将最大值和最小值都计算出来，但怎么返回呢？可以定义一个类Pair，包括最大值和最小值，但Pair这个名字太普遍，而且它主要是类内部使用的，就可以定义为一个静态内部类。

我们也可以看一些在Java API中使用静态内部类的例子：

- Integer类内部有一个私有静态内部类IntegerCache，用于支持整数的自动装箱。
- 表示链表的LinkedList类内部有一个私有静态内部类Node，表示链表中的每个节点。
- Character类内部有一个public静态内部类UnicodeBlock，用于表示一个Unicode block。



## 3. **成员内部类**

### 3.1 **语法**

成员内部类没有static修饰符，少了一个static修饰符，但含义却有很大不同，示例代码如下：

```java
public class Outer {
    private int a = 100;
    
    public class Inner {
        public void innerMethod(){
            System.out.println("outer a " +a);
            Outer.this.action();
        }
    }
    
    private void action(){
        System.out.println("action");
    }
    
    public void test(){
        Inner inner = new Inner();
        inner.innerMethod();
    }
}
```

1. **成员内部类访问外部类成员：**

   Inner就是成员内部类，与静态内部类不同，**除了静态变量和方法，成员内部类还可以直接访问外部类的实例变量和方法**（所以需要先有外部类实例）
   1、如innerMethod直接访问外部类私有实例变量a。
   2、成员内部类还可以通过"外部类.this.xxx"的方式引用外部类的实例变量和方法，如Outer.this.action()，这种写法一般在重名的情况下使用，没有重名的话，"外部类.this."是多余的。

   在外部类内，使用成员内部类与静态内部类是一样的，直接使用即可，如test()方法所示。

2. **成员内部类的创建：**

   与静态内部类不同，成员内部类对象总是与一个外部类对象相连的，在外部使用时，它不能直接通过new Outer.Inner()的方式创建对象，而是要先将创建一个Outer类对象，代码如下所示：

   ```java
   Outer outer = new Outer();
   Outer.Inner inner = outer.new Inner();
   inner.innerMethod();
   ```

   创建内部类对象的语法是"外部类对象.new 内部类()"，如outer.new Inner()。

3. **注意：**
   与静态内部类不同，**成员内部类中不可以定义静态变量和方法 (final变量例外，它等同于常量）**，下面介绍的方法内部类和匿名内部类也都不可以。
   Java为什么要有这个规定呢？**具体原因不得而知，个人认为这个规定不是必须的，Java这个规定大概是因为这些内部类是与外部实例相连的，不应独立使用，而静态变量和方法作为类型的属性和方法，一般是独立使用的，在内部类中意义不大吧，而如果内部类确实需要静态变量和方法，也可以挪到外部类中**。

### 3.2 **实现原理**

以上代码也会生成两个类，一个是Outer，另一个是Outer$Inner，它们的代码大概如下所示：

```java
public class Outer {
    private int a = 100;

    private void action() {
        System.out.println("action");
    }

    public void test() {
        Outer$Inner inner = new Outer$Inner(this);
        inner.innerMethod();
    }

    static int access$0(Outer outer) {
        return outer.a;
    }

    static void access$1(Outer outer) {
        outer.action();
    }
}
```

```java
public class Outer$Inner {

    final Outer outer;
    
    public Outer$Inner(Outer outer){
        ths.outer = outer;
    }
    
    public void innerMethod() {
        System.out.println("outer a "
                + Outer.access$0(outer));
        Outer.access$1(outer);
    }
}
```

Outer\$Inner类有个实例变量outer指向外部类的对象，它在构造方法中被初始化，Outer在新建Outer\$Inner对象时传递当前对象给它，由于内部类访问了外部类的私有变量和方法，外部类Outer生成了两个非私有静态方法，access\$0用于访问变量a，access$1用于访问方法action。

### 3.3 **使用场景**

如果内部类与外部类关系密切，且操作或依赖外部类实例变量和方法，则可以考虑定义为成员内部类。

外部类的一些方法的返回值可能是某个接口，为了返回这个接口，外部类方法可能使用内部类实现这个接口，这个内部类可以被设为private，对外完全隐藏。

比如说，在Java API 类LinkedList中，它的两个方法`listIterator()`和`descendingIterator()`的返回值都是接口`Iterator`，调用者可以通过`Iterator`接口对链表遍历，`listIterator`和`descendingIterator`内部分别使用了成员内部类`ListItr`和`DescendingIterator`，这两个内部类都实现了接口`Iterator`。关于`LinkedList`，后续文章我们还会介绍。



## 4. **方法内部类**

### 4.1 语法

内部类还可以定义在一个方法体中，示例代码如下所示：

```java
public class Outer {
    private int a = 100;
    
    public void test(final int param){
        final String str = "hello";
        class Inner {
            public void innerMethod(){
                System.out.println("outer a " +a);
                System.out.println("param " +param);
                System.out.println("local var " +str);
            }
        }
        Inner inner = new Inner();
        inner.innerMethod();
    }
}
```

类Inner定义在外部类方法test中，**方法内部类只能在定义的方法内被使用**。

1. 如果方法是实例方法，则除了静态变量和方法，内部类还可以直接访问外部类的实例变量和方法，如innerMethod直接访问了外部私有实例变量a。// 方法外
2. 如果方法是静态方法，则方法内部类只能访问外部类的静态变量和方法。// 方法外
3. 方法内部类还可以直接访问方法的参数和方法中的局部变量，不过，**这些变量必须被声明为final**，如innerMethod直接访问了方法参数param和局部变量str。// 方法内

### 4.2 实现原理

系统生成的两个类代码大概如下所示：

```java
public class Outer {
    private int a = 100;

    public void test(final int param) {
        final String str = "hello";
        OuterInner inner = new OuterInner(this, param);
        inner.innerMethod();
    }
    
    static int access$0(Outer outer){
        return outer.a;
    }
}
```

```java
public class OuterInner {
    Outer outer;
    int param;
    
    OuterInner(Outer outer, int param){
        this.outer = outer;
        this.param = param;
    }
    
    public void innerMethod() {
        System.out.println("outer a "
                + Outer.access$0(this.outer));
        System.out.println("param " + param);
        System.out.println("local var " + "hello");
    }
}
```

与成员内部类类似，OuterInner类**也有一个实例变量outer指向外部对象**，在构造方法中被初始化，对外部私有实例变量的访问也是通过Outer添加的方法access$0来进行的。

方法内部类可以访问方法中的参数和局部变量，这是通过在构造方法中传递参数来实现的，如OuterInner构造方法中有参数int param，在新建OuterInner对象时，Outer类将方法中的参数传递给了内部类，如OuterInner inner = new OuterInner(this, param);。在上面代码中，String str并没有被作为参数传递，这是因为它被定义为了常量，在生成的代码中，可以直接使用它的值。

这也解释了，为什么方法内部类访问外部方法中的参数和局部变量时，这些变量必须被声明为final，因为实际上，方法内部类操作的并不是外部的变量，而是它自己的实例变量，只是这些变量的值和外部一样，对这些变量赋值，并不会改变外部的值，为避免混淆，所以干脆强制规定必须声明为final。

如果的确需要修改外部的变量，可以将变量改为只含该变量的数组，修改数组中的值，如下所示：

```java
public class Outer {
    public void test(){
        final String[] str = new String[]{"hello"};
        class Inner {
            public void innerMethod(){
                str[0] = "hello world";
            }
        }
        Inner inner = new Inner();
        inner.innerMethod();
        System.out.println(str[0]);
    }
}
```

str是一个只含一个元素的数组。

### 4.3 使用场景

方法内部类都可以用成员内部类代替，至于方法参数，也可以作为参数传递给成员内部类。不过，如果类只在某个方法内被使用，使用方法内部类，可以实现更好的封装。



## 5. **匿名内部类**

### 5.1语法

匿名内部类没有名字，在创建对象的同时定义类，语法如下：

```java
new 父类(参数列表) {
   //匿名内部类实现部分
}
```

或者

```java
new 父接口() {
   //匿名内部类实现部分
}
```

匿名内部类是与new关联的，在创建对象的时候定义类，new后面是父类或者父接口，然后是圆括号()，里面可以是传递给父类构造方法的参数，最后是大括号{}，里面是类的定义。

看个具体的代码：

```java
public class Outer {
    public void test(final int x, final int y){
        Point p = new Point(2,3){                             
            @Override                              
            public double distance() {             
                return distance(new Point(x,y));     
            }                                      
        };                                       
                                                 
        System.out.println(p.distance());        
    }
}
```

创建Point对象的时候，定义了一个匿名内部类，这个类的父类是Point，创建对象的时候，给父类构造方法传递了参数2和3，重写了distance()方法，在方法中访问了外部方法final参数x和y。

匿名内部类只能被使用一次，用来创建一个对象。它没有名字，**没有构造方法**，但可以根据参数列表，调用对应的父类构造方法。**它可以定义实例变量和方法，可以有初始化代码块**，初始化代码块可以起到构造方法的作用，只是构造方法可以有多个，而初始化代码块只能有一份。

因为没有构造方法，它自己无法接受参数，如果必须要参数，则应该使用其他内部类。

与方法内部类一样，匿名内部类也可以访问外部类的所有变量和方法，可以访问方法中的final参数和局部变量

### 5.2 实现原理

每个匿名内部类也都被生成为了一个独立的类，只是类的名字以外部类加数字编号，没有有意义的名字。上例中，产生了两个类Outer和Outer$1，代码大概如下所示：

```java
public class Outer {
    public void test(final int x, final int y){
        Point p = new Outer$1(this,2,3,x,y);                                            
        System.out.println(p.distance());        
    }
}
```

```java
public class Outer$1 extends Point {
    int x2;
    int y2;
    Outer outer;
    
    Outer$1(Outer outer, int x1, int y1, int x2, int y2){
        super(x1,y1);
        this.outer = outer;
        this.x2 = x2;
        this.y2 = y2;
    }
    
    @Override                              
    public double distance() {             
        return distance(new Point(this.x2,y2));     
    }   
}
```

与方法内部类类似，外部实例this，方法参数x和y都作为参数传递给了内部类构造方法。此外，new时的参数2和3也传递给了构造方法，内部类构造方法又将它们传递给了父类构造方法。

### 5.3 使用场景

匿名内部类能做的，方法内部类都能做。但如果对象只会创建一次，且不需要构造方法来接受参数，则可以使用匿名内部类，代码书写上更为简洁。

在调用方法时，很多方法需要一个接口参数，比如说Arrays.sort方法，它可以接受一个数组，以及一个Comparator接口参数，Comparator有一个方法compare用于比较两个对象。

比如说，我们要对一个字符串数组不区分大小写排序，可以使用Arrays.sort方法，但需要传递一个实现了Comparator接口的对象，这时就可以使用匿名内部类，代码如下所示：

```java
public void sortIgnoreCase(String[] strs){
    Arrays.sort(strs, new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            return o1.compareToIgnoreCase(o2);
        }
    });
}
```

Comparator后面的<Stirng>与泛型有关，表示比较的对象是字符串类型，后续文章会讲解泛型。

匿名内部类还经常用于事件处理程序中，用于响应某个事件，比如说一个Button，处理点击事件的代码可能类似如下：

```java
Button bt = new Button();
bt.addActionListener(new ActionListener(){
    @Override
    public void actionPerformed(ActionEvent e) {
        //处理事件
    }
});
```

调用addActionListener将事件处理程序注册到了Button对象bt中，当事件发生时，会调用actionPerformed方法，并传递事件详情ActionEvent作为参数。

以上Arrays.sort和Button都是上节提到的一种针对接口编程的例子，另外，它们也都是一种回调的例子。所谓回调是相对于一般的正向调用而言，平时一般都是正向调用，但Arrays.sort中传递的Comparator对象，它的compare方法并不是在写代码的时候被调用的，而是在Arrays.sort的内部某个地方回过头来调用的。Button中的传递的ActionListener对象，它的actionPerformed方法也一样，是在事件发生的时候回过头来调用的。

将程序分为保持不变的主体框架，和针对具体情况的可变逻辑，通过回调的方式进行协作，是计算机程序的一种常用实践。匿名内部类是实现回调接口的一种简便方式。

## 6. 小结

本节，我们谈了各种内部类的语法、实现原理、以及使用场景，内部类本质上都会被转换为独立的类，但一般而言，它们可以实现更好的封装，代码上也更为简洁。

我们一直没有讨论一个重要的问题，类放在哪里？类文件是如何组织的？本节中，自动生成的方法如access$0没有可见性修饰符，那可见性是什么？这些都与包有关，让我们下节来探讨。



原文：http://www.cnblogs.com/swiftma/p/5619071.html