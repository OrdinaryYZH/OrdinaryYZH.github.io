## 第2章 线程与锁

### 2.1 简单粗暴（略）

### 2.2 第一天：互斥和内存模型

#### 2.2.1 创建线程

```java
public class HelloWorld {

    public static void main(String[] args) throws InterruptedException {
        Thread myThread = new Thread() {
            @Override
            public void run() {
                System.out.println("Hello from new thread");
            }
        };

        myThread.start();
      → Thread.yield(); // 通知调度器：当前线程让出对处理器的占用
        System.out.println("Hello from main thread");
      → myThread.join(); // main线程等待myThread线程结束
    }
}
```

可能的结构是

"Hello from new thread"
"Hello from main thread"

或者
"Hello from main thread"
"Hello from new thread"

但是个人实验都是main + new...

#### 2.2.2 第一把锁

2个线程并发增加Count

未修改代码：

```java
public class Counting {
    public static void main(String[] args) throws InterruptedException {
        class Counter {
            private int count = 0;

            public void increment() {
                ++count;
            }

            public int getCount() {
                return count;
            }
        }

        final Counter counter = new Counter();
        class CountingThread extends Thread {
            @Override
            public void run() {
                for (int x = 0; x < 10000; ++x) {
                    counter.increment();
                }
            }
        }

        CountingThread t1 = new CountingThread();
        CountingThread t2 = new CountingThread();
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        System.out.println(counter.getCount()); // 此处的counter.getCount()安全，因为t1,t2已经join了
    }
}
```

产生的结果都不是20000，都是小于20000

##### 1. 问题原因

问题的原因是两个线程使用counter.count对象时发生了竞态条件（即代码执行结果取决于各操作的时序）

接下来详细分析下Java编译器是如何解释++count的：

```
getfield #2 // 获取count的值
iconst_1
iadd        // 2,3行将获得的值+1
putdield #2 // 设置值
```

这就是通称的**读 - 改 - 写 模式**

当2个线程同时调用increment()，线程1跟线程2都执行了getfield #2，得到42，然后再+1后，再写回count，那么都是43，结果count只递增了一次

##### 2. 解决方案

竞态条件的解决方案是都count进行同步访问。一种方法是使用Java对象那个原生的内置锁：

```java
        class Counter {
            private int count = 0;

          → public synchronized void increment() {
                ++count;
            }

            public int getCount() {
                return count;
            }
        }
```

其实这段程序还有问题，getCount也应该同步的，因为存在内存的不可见性；
对于这种只涉及一个变量的互斥场景，最好使用java.util.concurrent.atomic包

#### 2.2.3 诡异的内存

##### 1. 测试代码

```java
public class Puzzle {
  static boolean answerReady = false;
  static int answer = 0;
  static Thread t1 = new Thread() {
      public void run() {
      → answer = 42; 
      → answerReady = true; 
      }
    };
  static Thread t2 = new Thread() {
      public void run() {
        if (answerReady)
          System.out.println("The meaning of life is: " + answer);
        else
          System.out.println("I don't know the answer");
      }
    };

  public static void main(String[] args) throws InterruptedException {
    t1.start(); t2.start();
    t1.join(); t2.join();
  }
}
```

可能有以下结果

竞态条件：

1. The meaning of life is: 42
2. I don't know the answer

乱序执行：

3. The meaning of life is: 0

##### 2. 乱序执行

箭头的两行可能顺序颠倒了，因为有以下原因导致：

1. 编译器的静态优化
2. JVM的动态优化
3. 硬件可以通过乱序执行来优化其性能

##### 3. 不可见性

比乱序更糟糕的是，有时一个线程产生的修改可能对另一个线程不可见，如果将run()写成

```java
puvlic void run() {
    while(!answerReady) {
		Thread.sleep(100);
	}
	System.out.println("The meaning of life is:" + answer);
}
```

answerReady可能不会变成true，导致死循环。

>  （PS：详情请参考com/genericyzh/javase/thread/base/sevenweek/day1/puzzle包的代码，跟这里说的结果稍微不同）

所以需要标准来告诉我们，可能会发生什么副作用，这就是**Java内存模型**

#### 2.2.4 内存可见性

>  **Java内存模型基本原则是：如果读线程和写线程不进行同步，就不能保证可见性**

之前使用过的方法就是通过Class的内置锁；其他方法包括：

1. 开启一个线程并通过`join()`检查线程是否已经终止
2. 使用`java.util.concurrent`包提供多个工具

容易忽略的问题：**读线程和写线程都需要进行同步**；在2.2.2的解决方案中getCount()的线程仍可能获得一个失效的值

#### 2.2.5 多把锁

> 经上所述，容易得出一个结论：让多线程代码安全运行的方法只能是让所有的方法都同步。
>
> 然而，这也会带来问题：
>
> 1. 首先这样做效率低下
> 2. 当使用多把锁时，线程之间可能发生死锁

看下以下的“哲学家进餐问题”：五位哲学家绕桌而坐，桌上摆着5支筷子，哲学家可能处于"饥饿"和"思考"两个状态，饥饿时拿起左边筷子进餐，进餐完毕后放回筷子

```java
class Philosopher extends Thread {
    private Chopstick left, right;
    private Random random;
    private int thinkCount;

    public Philosopher(Chopstick left, Chopstick right) {
        this.left = left;
        this.right = right;
        random = new Random();
    }

    @Override
    public void run() {
        try {
            while (true) {
                ++thinkCount;
                if (thinkCount % 10 == 0) {
                    System.out.println("Philosopher " + this + " has thought " + thinkCount + " times");
                }
                Thread.sleep(random.nextInt(1000));     // Think for a while
              → synchronized (left) {                    // Grab left chopstick
              →     synchronized (right) {                 // Grab right chopstick
                        Thread.sleep(random.nextInt(1000)); // Eat for a while
                    }
                }
            }
        } catch (InterruptedException e) {
        }
    }
}
```

问题：所有人都拿起了左边筷子，然后等待后边筷子时，就发生了死锁

一个解决方法：**总是按照一个全局的固定顺序获取多把锁**

```java
class Philosopher extends Thread {
  → private Chopstick first, second;
    private Random random;
    private int thinkCount;

    public Philosopher(Chopstick left, Chopstick right) {
        if (left.getId() < right.getId()) {
            first = left;
            second = right;
        } else {
            first = right;
            second = left;
        }
        random = new Random();
    }

    @Override
    public void run() {
        try {
            while (true) {
                ++thinkCount;
                if (thinkCount % 10 == 0) {
                    System.out.println("Philosopher " + this + " has thought " + thinkCount + " times");
                }
                Thread.sleep(random.nextInt(1000));     // Think for a while
              → synchronized (first) {                   // Grab first chopstick
              →     synchronized (second) {                // Grab second chopstick
                        Thread.sleep(random.nextInt(1000)); // Eat for a while
                    }
                }
            }
        } catch (InterruptedException e) {
        }
    }
}
```

问题：可以用对象的hash值作为锁的全局顺序吗？

hash小的为first，打的为second

弊端：hashCode可能重复

> 总结：死锁的判断：锁的等待链不出现**有向无环图**，类似数据库中事务的等待图：
>
> ![](https://img.draveness.me/2017-10-02-deadlock-wait-for-graph.png)
>
> 参考：[浅谈数据库并发控制 - 锁和 MVCC](https://draveness.me/database-concurrency-control)

#### 2.2.6 来自外星方法的危害

举个例子：我们构造一个类从一个URL进行下载，并从ProgressListeners监听下载的速度

```java
class Downloader extends Thread {
    private InputStream in;
    private OutputStream out;
    private ArrayList<ProgressListener> listeners;

    public Downloader(URL url, String outputFilename) throws IOException {
        in = url.openConnection().getInputStream();
        out = new FileOutputStream(outputFilename);
        listeners = new ArrayList<ProgressListener>();
    }

    public synchronized void addListener(ProgressListener listener) {
        listeners.add(listener);
    }

    public synchronized void removeListener(ProgressListener listener) {
        listeners.remove(listener);
    }

    private synchronized void updateProgress(int n) {
        for (ProgressListener listener : listeners)
→           listener.onProgress(n);
    }

    @Override
    public void run() {
        int n = 0, total = 0;
        byte[] buffer = new byte[1024];

        try {
            while ((n = in.read(buffer)) != -1) {
                out.write(buffer, 0, n);
                total += n;
→               updateProgress(total);
            }
            out.flush();
        } catch (IOException e) {
        }
    }
}
```

尽管这段代码仅使用了一把锁，但仍隐藏着一个死锁陷阱

陷阱在于`updateProgress()`调用了一个外形方法 -- 但对于这个外星方法一无所知。外星方法可以做任何事情，例如持有另外一把锁。这样一来，我们就在对加锁顺序一无所知的情况下使用了两把锁，这时候就可能发生死锁。

唯一的解决思路是避免持有锁时调用外星方法。一种方法是在遍历之前对listeners进行**保护性复制**，在针对这份副本进行遍历：

```java
    private void updateProgress(int n) {
        ArrayList<ProgressListener> listenersCopy;
        synchronized (this) {
            listenersCopy = (ArrayList<ProgressListener>) listeners.clone();
        }
        for (ProgressListener listener : listenersCopy) {
            listener.onProgress(n);
        }
    }
```

有以下好处：

1. 不仅在调用外星方法时不用加锁，而且大大减少了代码持有所的时间
2. 保护性复制修复了与并发无关的bug —— 修复后如果监听器在`onProgress()`中调用`removeListener()`，将不会影响到正在遍历的副本

#### 2.2.7 第一天总结

线程与锁模型带来的三个主要危害：

1. 竞态条件
2. 内存可见性
3. 死锁

避免危害的准则：

1. 对共享变量的所有访问都需要同步化
2. 读线程和写线程都需要同步化
3. 按照约定的全局顺序来获取多把锁
4. 当持有锁时避免调用外星方法
5. 持有锁的时间应尽可能短



