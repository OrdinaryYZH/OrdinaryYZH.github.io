## 第2章-实现用户登录以及分布式session功能

### 2.1 利用函数方法（Lambda）封装Redis

![](https://ws1.sinaimg.cn/large/8747d788gy1fyn00uh6f9j21h00sstc1.jpg)

重点关注下RedisClient吧：

```java
public class RedisClient {

    private RedisPoolFactory redisPoolFactory;

    public RedisClient(RedisPoolFactory redisPoolFactory) {
        this.redisPoolFactory = redisPoolFactory;
    }

    public <R> R execute(Function<Jedis, R> fun) {
        Jedis jedis = redisPoolFactory.getJedis();
        return fun.apply(jedis);
    }

    public <R, S> R execute(Function<Jedis, S> fun, Class<R> clz) {
        Jedis jedis = redisPoolFactory.getJedis();
        S apply = fun.apply(jedis);
        return SerializeUtil.stringToBean((String) apply, clz);
    }

}
```

参考：

1. [使用Java8的函数式接口简化代码](https://segmentfault.com/a/1190000011914930)
2. https://github.com/jsondream/redisses/blob/master/redisses-client/src/main/java/com/jsondream/redisses/client/RedisPoolClient.java

### 2.2 关于Key的封装

效果：

![](https://ws1.sinaimg.cn/large/8747d788gy1fyn0lzp688j21fr08ldgp.jpg)

代码实现：

![](https://ws1.sinaimg.cn/large/8747d788gy1fyn0mqv9uqj21hn0w7q83.jpg)

为什么不使用Enum？（因为Enum不能继承类）

前提：一个模块中可能使用多个key，一个类代表一个模块，一个实例代表模块下的子模块key；
使用Enum不能复用父类的getPrefix()，要每个Enum都要写一次。。

### 2.3 登录功能

数据库的设计

* 用户表

```mysql
CREATE TABLE IF NOT EXISTS miaosha_user (
  id           VARCHAR(16) NOT NULL
  COMMENT
    '手机',
  nickname     VARCHAR(255),
  PASSWORD     VARCHAR(32) NOT NULL,
  salt         VARCHAR(10) NOT NULL,
  head         VARCHAR(255),
  gmt_create   DATETIME    NOT NULL,
  gmt_modified DATETIME    NOT NULL,
  PRIMARY KEY (id)
)
  ENGINE = INNODB
  DEFAULT CHARSET = utf8
  COMMENT '用户表';
```

2次md5，客户端一次（~~防止网络被截取包~~），服务端一次（为了不存明文密码）

![](https://ws1.sinaimg.cn/large/8747d788gy1fyxd2caldkj211t0o4401.jpg)

* 问题：http下，如果被偷包，直接发送窃取到的密码发送给server端也可登录成功，没啥意义

server端多次hash是有用的，客户端就没用(在http下)

### 2.4 jsr303参数校验，自定义注解校验手机号

1. 引入springboot-starter-validation
2. 自定义是否是手机校验注解：@IsMobile + IsMobileValidator类（实现ConstraintValidator接口），还有个ValidatorUtil，校验手机的方法

@IsMobile

```java
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {IsMobileValidator.class })
public @interface IsMobile {
	
	boolean required() default true;
	
	String message() default "手机号码格式错误";

	Class<?>[] groups() default { };

	Class<? extends Payload>[] payload() default { };
}
```

这三个属性对于约束注释是必需的：

- ***message*** – returns the default key for creating error messages, this enables us to use message interpolation
- ***groups*** – allows us to specify validation groups for our constraints
- ***payload*** – 这个不太会用，也没用过。can be used by clients of the Bean Validation API to assign custom payload objects to a constraint

校验器：自定义IsMobileValidator

```java
public class IsMobileValidator implements ConstraintValidator<IsMobile, String> {

    private boolean required = false;

    @Override
    public void initialize(IsMobile constraintAnnotation) {
        required = constraintAnnotation.required();
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        if (required) {
            return ValidatorUtil.isMobile(value);
        } else {
            if (StringUtils.isEmpty(value)) {
                return true;
            } else {
                return ValidatorUtil.isMobile(value);
            }
        }
    }

}
```

图解：

![](https://ws1.sinaimg.cn/large/8747d788gy1fyyblia49lj21nw08uabc.jpg)

全局异常，异常信息定义

### 2.5 分布式session，redis，延长cookie时间 

分布式session是什么?

> 分布式和集群:
>
> 小饭店原来只有一个厨师，切菜洗菜备料炒菜全干。后来客人多了，厨房一个厨师忙不过来，又请了个厨师，两个厨师都能炒一样的菜，这两个厨师的关系是集群。为了让厨师专心炒菜，把菜做到极致，又请了个配菜师负责切菜，备菜，备料，厨师和配菜师的关系是分布式，一个配菜师也忙不过来了，又请了个配菜师，两个配菜师关系是集群
>
> 链接：https://www.zhihu.com/question/20004877/answer/112124929

WebMvcConfigurerAdapter + HandlerMethodArgumentResolver填充Controller参数

其他:

1. SLF4j日志配置，日志格式配置

## 第3章-秒杀功能开发及管理后台

1. 数据库设计：
   1. 商品表
   2. 订单表
   3. 秒杀商品表
   4. 秒杀订单表
2. 商品列表页

[项目整理-页面缓存和URL缓存](https://www.liuyaois.me/2018-07-28-%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86-%E9%A1%B5%E9%9D%A2%E7%BC%93%E5%AD%98%E5%92%8CURL%E7%BC%93%E5%AD%98/index.html)

https://www.liuyao.site/ye-mian-huan-cun-he-urlhuan-cun/

1. 商品详情页
2. 秒杀功能实现

## 第4章-秒杀压测-Jmeter压力测试

JMeter入门
自定义变量模拟多用户
JMeter命令行使用
Redis压测工具redis-benchmark
spring boot 打包war
问题：超卖了

## 第5章-页面级高并发秒杀优化（Redis缓存+静态化分离）

1. 页面缓存 + URL缓存 + 对象缓存

   1. 页面缓存
      缓存的时间比较短，60s左右；
      未解决的问题：更新数据库 + 更新缓存的时候出错了/停电了咋办？
      注意：先更新数据库，在更新缓存：试想，两个并发操作，一个是更新操作，另一个是查询操作，更新操作删除缓存后，查询操作没有命中缓存，先把老数据读出来后放到缓存中，然后更新操作更新了数据库。于是，在缓存中的数据还是老的数据，导致缓存中的数据是脏的，而且还一直这样脏下去了。

      ```java
          @RequestMapping(value="/to_list", produces="text/html")
          @ResponseBody
          public String list(HttpServletRequest request, HttpServletResponse response, Model model,MiaoshaUser user) {
          	model.addAttribute("user", user);
          	//取缓存
          	String html = redisService.get(GoodsKey.getGoodsList, "", String.class);
          	if(!StringUtils.isEmpty(html)) {
          		return html;
          	}
          	List<GoodsVo> goodsList = goodsService.listGoodsVo();
          	model.addAttribute("goodsList", goodsList);
      //    	 return "goods_list";
          	SpringWebContext ctx = new SpringWebContext(request,response,
          			request.getServletContext(),request.getLocale(), model.asMap(), applicationContext );
          	//手动渲染
          	html = thymeleafViewResolver.getTemplateEngine().process("goods_list", ctx);
          	if(!StringUtils.isEmpty(html)) {
          		redisService.set(GoodsKey.getGoodsList, "", html);
          	}
          	return html;
          }
      ```

      ​

2. 页面静态化，前后端分离

   1. 商品详情静态化

   2. 秒杀页静态化

      1. get和post的区别
         1. GET:幂等，如果是存在这种：<a href = "xxx/delete?id=xxx"/>可能被搜索引擎执行到。。
         2. POST:

   3. 订单详情静态化

   4. 解决问题

      1. 解决超卖：修改sql，加上and stock_count > 0

      2. 防止用户买到2个：秒杀订单表添加userId + goods唯一索引，insert第二个的时候会报错回滚
         ![](https://ws1.sinaimg.cn/large/8747d788gy1frjc0w5jrlj21vc15d7wh.jpg)

         > 对（uid,goods_id）加唯一索引！！      
         >
         >   start transaction;
         >
         >       insert into buy_record。。。  
         >
         >   if(唯一索引报错？)
         >
         >       抛异常，已经秒过了，回滚。。。
         >        
         >             update goods set goods_num=goods_num-1 where goods_id=$goods_id  and  goods_num>0            ;      
         >
         >   if(受影响行数<=0)
         >
         >       抛异常，商品秒完了，回滚。。。
         >        
         >       该方法完美的解决了超卖与select排它锁导致的并发低的问题，并且4个sql缩减成2个sql语句。极大提升性能  

3. 静态资源优化


4. CDN优化

   ​

## 第6章-服务级高并发秒杀优化（RabbitMQ+接口优化）

> 思路：减少数据库访问
>
> 1. 系统初始化，把商品库存数量加载到Redis
> 2. 收到请求，Redis预减库存，库存不足，直接返回，否则第三步
> 3. 请求入队，立即返回排队中
> 4. 请求出队，生成订单，减少库存
> 5. 客户端轮训，是否秒杀成功

1. Redis预减库存减少数据库访问
2. 内存标记减少Redis访问
3. 请求先入队缓冲，异步下单，增强用户体验
4. Nginx
5. 压测

BUG:预减库存问题：用户1秒杀成功后，继续下单，redis直接-1.

## 第7章-图形验证码及恶意防刷

1. 秒杀接口地址隐藏
   先请求一次得到秒杀路径，把路径存到redis中，再根据请求的路径发秒杀请求，服务端判断路径是否正确再继续执行
   分析：原来的做法有问题，返回的秒杀路径在60s之内有效，太长了，也可以被刷接口；可以设置时间短一点，或者路径只使用一次就失效（如果被知道这种防刷方式的话，也可以提前写个脚本刷，不过可能性比较低）
2. 数学公式验证码
   1. 好处：
      1. 防止机器人
      2. 分散用户请求
   2. 思路：
      1. 添加生成验证码的接口
      2. 在获取秒杀路径的时候，验证验证码
      3. ScriptEngine使用
3. 接口限流防刷
   自定义注解统一处理Controller接口访问次数
   1. 使用拦截器
   2. 使用Redis存接口规定时间内的访问次数
   3. 自定义注解还有个需要登录的属性

## 问题

1. 用缓存重点应该考虑在秒杀完之后，如果有用户不付款取消订单后，库存怎么处理。因为你目的要把货全卖出去，不能光考虑不超卖，也得考虑少卖的情况。

   > 利用MQ（Rabbitmq）,DLX （Dead Letter Exchanges）和 消息的 TTL （Time-To-Live Extensions）特性
   >
   > 发送到队列的消息，可以设置一个存活时间 TTL，在存活时间内没有被消费，可以设置这个消息转发到其他队列里面去；然后我们从这个其他队列里面消费执行我们的任务，这样就可以达到一个消息延时的效果！
   >
   > 参考：[高并发的核心技术 - 消息中间件（MQ）](http://jblog.top/article/details/254951)

2. 数据校验问题，Controller中的参数校验问题，如果只是简单的数据类型，需要自定义注解处理